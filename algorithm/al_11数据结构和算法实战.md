# 数据结构的存储方式

##　基本的存储结构

基本的存储结构只有两种：

- 数组（顺序存储）
- 链表（链式存储）

二者的特点：

### 数组

- **数组**由于是紧凑连续存储,可以随机访问， 通过索引快速找到对应元素， ⽽且相对节约存储空间。  但正因为连续存储， 内存空间必须⼀次性分配够， 所以说数组如果要扩容， 需要重新分配⼀块更⼤的空间， 再把数据全部复制过去， 时间复杂度 O(N)；  
- 如果想在数组中间进⾏插⼊和删除， 每次必须搬移后⾯的所有数据以保持连续， 时间复杂度 O(N)  

### 链表  

- **链表** 因为元素不连续， ⽽是靠指针指向下⼀个元素的位置， 所以不存在数组的扩容问题； 如果知道某⼀元素的前驱和后驱， 操作指针即可删除该元素或者插⼊新元素， 时间复杂度 O(1)。    但是正因为存储空间不连续， 你⽆法根据⼀个索引算出对应元素的地址， 所以不能随机访问；   ⽽且由于每个元素必须存储指向前后元素位置的指针， 会消耗相对更多的储存空间 .

## 上层数据结构

散列表、 栈、 队列、 堆、 树、 图等等各种数据结构  都属于上层数据结构，都是以 数组或者链表为基础结构 构建出来的。

### 队列、 栈

「队列」 、 「栈」 这两种数据结构既可以使⽤链表也可以使⽤数组实现。  

- ⽤数组实现， 就要处理扩容缩容的问题；  
- 链表实现， 没有扩容问题，但需要更多的内存空间存储节点指针。  

### 图

「图」 的两种表⽰⽅法， 邻接表就是链表， 邻接矩阵就是⼆维数组。  

- 邻接矩阵：判断连通性迅速， 并可以进⾏矩阵运算解决⼀些问题， 但是如果图⽐较稀疏的话很耗费空间。  
- 邻接表：⽐较节省空间， 但是很多操作的效率上肯定⽐不过邻接矩阵  

### 散列表

通过散列函数把键映射到⼀个⼤数组⾥。 ⽽且对于解决散列冲突的⽅法， 拉链法需要链表特性， 操作简单， 但需要额外的空间存储指
针； 线性探查法就需要数组特性， 以便连续寻址， 不需要指针的存储空间，但操作稍微复杂些  

### 树

⽤数组实现就是「堆」 ， 因为「堆」 是⼀个完全⼆叉树， ⽤数组存储不需要节点指针， 操作也⽐较简单； ⽤链表实现就是很常⻅的那种 。

「树」 ， 因为不⼀定是完全⼆叉树， 所以不适合⽤数组存储。 为此， 在这种链表「树」 结构之上， ⼜衍⽣出各种巧妙的设计， ⽐如  

- ⼆叉搜索树  
- AVL 树 
- 红⿊树  
- 区间树  
- B 树 

# 数据结构的基本操作

数据结构的基本操作无非两种： 遍历 + 访问

具体一点： 增删改

数据结构的遍历和访问方式（两种）：线性和非线性

- 线性：for/while
- 非线性：递归

## 数组的遍历框架- 典型的线性迭代结构

```java
void traverse(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
    	// 迭代访问 arr[i]
    }
}
```

## 链表的遍历框架-迭代和递归结构

```java
//基本的节点
class ListNode{
    int val;
  	ListNode next;
}

//for 循环方式
void traverse(ListNode head) {
    for (ListNode p = head; p!= null; p = p.next) {
    	// 迭代访问 p.val
    }
}

//while 方式
void traverse2(ListNode head){
    ListNode p = head;
    while(p != null){
        // 迭代访问 p.val
        p = p.next;
    }
}

// 递归方式遍历
void traverse3(ListNode head){
    traverse3(head.next);
}
```

## 二叉树的遍历框架-典型的递归遍历结构

```java
// 基本的⼆叉树节点
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
}
//递归遍历
void traverse(TreeNode root){
    traverse(root.left);
    traverse(root.right);
}
```

你看⼆叉树的递归遍历⽅式和链表的递归遍历⽅式， 相似不？ 再看看⼆叉树结构和单链表结构， 相似不？ 如果再多⼏条叉， N 叉树你会不会遍历？  

⼆叉树框架可以扩展为 N 叉树的遍历框架  ：

```java
/* 基本的 N 叉树节点 */
class TreeNode {
    int val;
    TreeNode[] children;
} 
void traverse(TreeNode root) {
    for (TreeNode child : root.children)
    	traverse(child)
    }
}
```

N 叉树的遍历⼜可以扩展为图的遍历， 因为图就是好⼏ N 叉棵树的结合体  

图是可能出现环的？ 这个很好办， ⽤个布尔数组 visited 做标记就⾏了， 这⾥就不写代码了。  

### 总结

所谓框架， 就是套路。 不管增删查改， 这些代码都是永远⽆法脱离的结构，你可以把这个结构作为⼤纲， 根据具体问题在框架上添加代码就⾏了， 下⾯会具体举例。  

# 算法刷题指南

⾸先要明确的是， **数据结构是⼯具， 算法是通过合适的⼯具解决特定问题的⽅法。**  也就是说， 学习算法之前， 最起码得了解那些常⽤的数据结构， 了解它们的特性和缺陷。  

**先刷⼆叉树， 先刷⼆叉树， 先刷⼆叉树！**

因为⼆叉树是最容易培养框架思维的， ⽽且⼤部分算法技巧， 本质上都是树的遍历问学习算法和刷题的框架思维题。    

刷⼆叉树看到题⽬没思路？ 根据很多读者的问题， 其实⼤家不是没思路， 只是没有理解我们说的「框架」 是什么。 不要⼩看这⼏⾏破代码， ⼏乎所有⼆叉树的题⽬都是⼀套这个框架就出来了。

```java
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}
```

  刷算法题建议从「树」 分类开始刷， 结合框架思维， 把这⼏⼗道题刷完， 对于树结构的理解应该就到位了。 这时候去看回溯、 动规、 分治等算法专题，对思路的理解可能会更加深刻⼀些 。


# 十大排序算法



![image-20210117130713082](Untitled/image-20210117130713082.png)

# 分类

## 比较排序

### 交换类

#### 冒泡排序

交换排序的典型，也是快排思想的基础，冒泡排序是一种稳定排序算法。

- 时间复杂度：O(n^2).
- 基本思想：**循环遍历多次，每次从前往后把大元素往后调，每次确定一个最大（最小）元素，多次后达到排序序列。（或者从后往前把小元素往前调）**

#### 实现思路

- 从第一个元素开始往后遍历，每一个位置判断是否比后面的元素大，如果比后面的元素大，那么就交换两者大小，然后继续向后，这样的话进行一轮之后就可以保证**「最大的那个数被交换交换到最末的位置可以确定」**。
- 第二次同样从开始起向后判断着前进，如果当前位置比后面一个位置更大的那么就和他后面的那个数交换。但是有点注意的是，这次并不需要判断到最后，只需要判断到倒数第二个位置就行(因为第一次我们已经确定最大的在倒数第一，这次的目的是确定倒数第二)
- 同理，后面的遍历长度每次减一，直到第一个元素使得整个元素有序。

![image-20210117133433984](Untitled/image-20210117133433984.png)

代码实现：

```python
def bubble_sort(arr):
    """
    冒泡算法
    :return:
    """
    length = len(arr)
    # 第一层遍历(表示比较的次数)
    for i in range(length):
        # 数据处理
        for j in range(1, length - i):
            if arr[j - 1] > arr[j]:
                # 两者交换数据，这里没用temp，因为python 特性： 元组
                arr[j - 1], arr[j] = arr[j], arr[j - 1]

    return arr


def bubble_sort_flag(arr):
    """
    带标记的排序算法
    :param arr:
    :return:
    """
    length = len(arr)
    for index in range(length):
        flag = True
        for j in range(1,length-index):
            if arr[j-1] > arr[j]:
                arr[j],arr[j-1] = arr[j-1], arr[j]
                flag = False
        # 表示排序已经完成，则直接退出
        if flag:
            return arr
    return arr
```



### 快速排序

快速排序是对冒泡排序的一种改进，采用递归分制的方法进行求解。快速排序是一种不稳定的排序方法。

- 时间复杂度：最坏是O(n^2)，平均时间复杂度为O(nlogn),最好情况的时间复杂度为O(nlogn)

#### 基本思想

- 快排需要将序列变成两个部分，就是**「序列左边全部小于一个数」**，**「序列右面全部大于一个数」**，然后利用递归的思想再将左序列当成一个完整的序列再进行排序，同样把序列的右侧也当成一个完整的序列进行排序。
- 其中这个数在这个序列中是可以随机取的，可以取最左边，可以取最右边，当然也可以取随机数。但是**「通常」**不优化情况我们取最左边的那个数。

![image-20210117142802201](Untitled/image-20210117142802201.png)



#### 插入类



#### 选择类



#### 并归类





### 非比较排序



#### 桶排序

#### 基数排序

### 计数排序

